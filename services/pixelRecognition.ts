// 像素识别服务
// 专门用于9x9像素网格的数字识别

export interface PixelRecognitionResult {
  digit: number
  confidence: number
  explanation: string
}

// 9x9像素数字模板
const PIXEL_TEMPLATES = {
  0: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  1: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 255, 0, 0, 0, 0],
    [0, 0, 0, 255, 255, 0, 0, 0, 0],
    [0, 0, 255, 255, 255, 0, 0, 0, 0],
    [0, 0, 0, 255, 255, 0, 0, 0, 0],
    [0, 0, 0, 255, 255, 0, 0, 0, 0],
    [0, 0, 0, 255, 255, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  2: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  3: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  4: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  5: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  6: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  7: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 255, 255, 0],
    [0, 0, 0, 0, 0, 255, 255, 0, 0],
    [0, 0, 0, 0, 255, 255, 0, 0, 0],
    [0, 0, 0, 255, 255, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  8: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ],
  9: [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 255, 0],
    [0, 255, 255, 255, 255, 255, 255, 255, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ]
}

// 识别9x9像素网格中的数字
export function recognizePixelDigit(pixels: number[][]): PixelRecognitionResult {
  if (!pixels || pixels.length !== 9 || pixels[0].length !== 9) {
    return {
      digit: 0,
      confidence: 0,
      explanation: "无效的像素网格"
    }
  }

  // 将像素值转换为二值化（0或255）
  const binaryPixels = pixels.map(row => 
    row.map(pixel => pixel < 128 ? 0 : 255)
  )

  let bestMatch = { digit: 0, score: Infinity }
  
  // 与每个数字模板比较
  for (const [digitStr, template] of Object.entries(PIXEL_TEMPLATES)) {
    const digit = parseInt(digitStr)
    const score = calculatePixelSimilarity(binaryPixels, template)
    
    if (score < bestMatch.score) {
      bestMatch = { digit, score }
    }
  }

  // 计算置信度（分数越低，置信度越高）
  const confidence = Math.max(0, Math.min(1, 1 - bestMatch.score / 81)) // 81是总像素数
  
  const explanations = {
    0: "这是一个圆形，很可能是数字 0！",
    1: "这是一个垂直的细长形状，很可能是数字 1！",
    2: "这是一个S形，很可能是数字 2！",
    3: "这是一个E形，很可能是数字 3！",
    4: "这是一个F形，很可能是数字 4！",
    5: "这是一个S形，很可能是数字 5！",
    6: "这是一个圆形，很可能是数字 6！",
    7: "这是一个L形，很可能是数字 7！",
    8: "这是一个双圆形，很可能是数字 8！",
    9: "这是一个圆形，很可能是数字 9！"
  }

  return {
    digit: bestMatch.digit,
    confidence,
    explanation: explanations[bestMatch.digit as keyof typeof explanations] || "无法识别的数字"
  }
}

// 计算两个像素网格的相似度
function calculatePixelSimilarity(pixels1: number[][], pixels2: number[][]): number {
  let differences = 0
  
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (pixels1[i][j] !== pixels2[i][j]) {
        differences++
      }
    }
  }
  
  return differences
}

// 计算与目标数字的相似度
export function calculateTargetSimilarity(pixels: number[][], targetDigit: number): number {
  const template = PIXEL_TEMPLATES[targetDigit as keyof typeof PIXEL_TEMPLATES]
  if (!template) return 0

  const binaryPixels = pixels.map(row => 
    row.map(pixel => pixel < 128 ? 0 : 255)
  )

  const differences = calculatePixelSimilarity(binaryPixels, template)
  return Math.max(0, 1 - differences / 81)
}

// 获取数字3的初始模板
export function getDigit3Template(): number[][] {
  return PIXEL_TEMPLATES[3].map(row => [...row])
}
